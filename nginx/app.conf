# ----------------------------------------------------------------------
# DNS Resolver (Docker)
# ----------------------------------------------------------------------

# Nginx resolves upstream hostnames only at startup unless `resolve` is used.
# In Docker, container IPs can change (e.g., after `docker compose up --build`),
# which leads to intermittent 502s from stale upstream addresses.
# Keep `valid` small so Nginx doesn't cache NXDOMAIN/stale results for long
# during local container rebuilds/recreates.
resolver 127.0.0.11 ipv6=off valid=5s;
resolver_timeout 5s;

# ----------------------------------------------------------------------
# Logging (Debug Upload Failures)
# ----------------------------------------------------------------------
#
# When uploads are interrupted mid-stream, Nginx can respond with 400 and the
# upstream may log an incomplete request. Include request length + Content-Length
# to quickly identify client-aborted/incomplete bodies.
log_format gateway_main '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent '
                        'req_len=$request_length cl=$http_content_length '
                        'rt=$request_time '
                        '"$http_referer" "$http_user_agent" "$http_x_forwarded_for"';

# ----------------------------------------------------------------------
# Upstream Definitions
# ----------------------------------------------------------------------

upstream auth_static {
    # upstream: 백엔드 서버 그룹을 정의해서 proxy_pass에서 이름만으로 라우팅할 수 있게 한다.
    # server: 실제 대상 호스트:포트를 지정한다.
    # keepalive 풀(여러 worker가 동일 커넥션을 재사용)
    zone auth_static 64k;
    server auth-web-static:4173 resolve;
    keepalive 16;
}

upstream auth_service {
    zone auth_service 64k;
    server auth-service:8080 resolve;
}

upstream media_service {
    zone media_service 64k;
    server media-service:4000 resolve;
}

upstream search_service {
    zone search_service 64k;
    server search-service:4002 resolve;
}

# ----------------------------------------------------------------------
# Variable Mappings
# ----------------------------------------------------------------------

map $upstream_http_x_user_id $auth_user_id {
    # map: 입력 변수에 따라 출력 변수를 매핑하는 디렉티브.
    # default: 어떤 패턴에도 매치되지 않을 때 사용할 기본값.
    default $upstream_http_x_user_id;
}

map $upstream_http_x_user_role $auth_user_role {
    default $upstream_http_x_user_role;
}

# Prefer bearer from cookie `token` when present; otherwise use incoming Authorization header.
map $cookie_token $auth_header {
    ""       $http_authorization;
    default  "Bearer $cookie_token";
}

map $swagger_service $swagger_upstream {
    # swagger 프록시에서 서비스별 업스트림을 고정하는 매핑.
    # 필요 시 여기에 다른 서비스명을 추가하면 동일한 패턴으로 라우팅된다.
    default "";
    auth    auth-service:8080;
    auth-service auth-service:8080;
}

# ----------------------------------------------------------------------
# Server Configuration
# ----------------------------------------------------------------------

server {
    # server: 가상 서버 블록. 해당 블록에서 listen/server_name 등 가상 호스트 설정을 정의한다.
    listen 80;
    server_name _;
    client_max_body_size 10m;
    access_log /var/log/nginx/access.log gateway_main;
    error_log /var/log/nginx/error.log info;

    # Handle large JWT tokens in headers
    client_header_buffer_size 8k;
    large_client_header_buffers 8 64k;

    # ------------------------------------------------------------------
    # Frontend (Static Files)
    # ------------------------------------------------------------------
    location / {
        # location: 특정 URI 패턴과 매칭되는 요청 처리 블록.
        # proxy_pass: 요청을 지정한 upstream 또는 실제 URL로 전달한다.
        proxy_pass http://auth_static;
        include /etc/nginx/includes/proxy_headers.conf;
    }

    # ------------------------------------------------------------------
    # Internal Auth Request
    # ------------------------------------------------------------------
    location = /internal/auth {
        # location = : 정확히 같은 경로에만 매칭.
        # internal: 외부 요청으로는 접근할 수 없고 내부 리다이렉션으로만 호출 가능.
        internal;
        proxy_pass http://auth_service/auth/validate;
        
        # Internal auth headers
        proxy_set_header Host $host;
        proxy_set_header Authorization $auth_header;
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-Original-Method $request_method;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
    }

    # ------------------------------------------------------------------
    # Auth Service Public API
    # ------------------------------------------------------------------
    location ~ ^/api/v1/auth/(signup|login|refresh)$ {
        # location ~ : 정규식 매칭을 의미하며 대소문자를 구분한다.
        # ^/api/v1/auth/(signup|login|refresh)$ 는 signup/login/refresh 세 엔드포인트만 매칭.
        # 공개 인증 API는 토큰 검증 없이 바로 auth-service로 전달.
        proxy_pass http://auth_service;
        include /etc/nginx/includes/proxy_headers.conf;
    }

    location /auth/validate {
        # 클라이언트가 직접 인증 서버의 validate 엔드포인트를 호출하는 경우.
        proxy_pass http://auth_service/auth/validate;
        proxy_set_header Host $host;
        proxy_set_header Authorization $http_authorization;
    }

    # ------------------------------------------------------------------
    # Auth Service Protected API
    # ------------------------------------------------------------------
    location /api/ {
        # 기타 /api/* 요청은 auth_request를 통해 사전 인증을 수행.
        auth_request /internal/auth;
        auth_request_set $auth_user_id $upstream_http_x_user_id;

        proxy_pass http://auth_service;
        include /etc/nginx/includes/proxy_headers.conf;
        
        # Propagated Auth Headers
        proxy_set_header X-User-Id $auth_user_id;
        proxy_set_header Authorization $http_authorization;
    }

    # ------------------------------------------------------------------
    # Media Service
    # ------------------------------------------------------------------
    location /media {
        auth_request /internal/auth;
        auth_request_set $auth_user_id $upstream_http_x_user_id;
        auth_request_set $auth_user_role $upstream_http_x_user_role;

        client_max_body_size 20m;
        proxy_pass http://media_service;
        include /etc/nginx/includes/proxy_headers.conf;

        # Propagated Auth Headers
        proxy_set_header Authorization $auth_header;
        proxy_set_header X-User-Id $auth_user_id;
        proxy_set_header X-User-Role $auth_user_role;
    }

    # ------------------------------------------------------------------
    # Search Service
    # ------------------------------------------------------------------
    location /search {
        auth_request /internal/auth;
        auth_request_set $auth_user_id $upstream_http_x_user_id;

        proxy_pass http://search_service;
        include /etc/nginx/includes/proxy_headers.conf;

        # Propagated Auth Headers
        proxy_set_header X-User-Id $auth_user_id;
    }

    # ------------------------------------------------------------------
    # Swagger UI Proxy
    # ------------------------------------------------------------------
    location ~ ^/swagger/(?<swagger_service>[a-zA-Z0-9_-]+)(?<swagger_path>/.*)?$ {
        # prefix 기반 swagger 라우팅: /swagger/{service}/** -> {service}-service 로 전달
        # 알 수 없는 서비스명은 404 반환.
        if ($swagger_upstream = "") { return 404; }

        # 경로가 /swagger/{service} 로 끝나면 슬래시를 붙여서 자원 경로가 어긋나지 않게 처리.
        if ($swagger_path = "") { return 301 $scheme://$http_host/swagger/$swagger_service/; }

        # 루트(/swagger/{service}/) 접근 시 swagger UI 기본 페이지로 연결.
        set $swagger_target $swagger_path;
        if ($swagger_target = "/") { set $swagger_target /swagger-ui/index.html; }
        if ($swagger_target !~ ^/(swagger-ui/|v3/api-docs)) { set $swagger_target /swagger-ui$swagger_target; }

        proxy_pass http://$swagger_upstream$swagger_target;
        include /etc/nginx/includes/proxy_headers.conf;
        proxy_set_header X-Forwarded-Prefix /swagger/$swagger_service;
    }

    # ------------------------------------------------------------------
    # Error Handling
    # ------------------------------------------------------------------
    error_page 401 = @unauthorized;

    location @unauthorized {
        # location @name: 명명된 내부 location, error_page 등에서 참조한다.
        # default_type: 응답의 Content-Type 헤더를 지정한다.
        default_type application/json;
        return 401 '{"message":"Unauthorized"}';
    }
}
